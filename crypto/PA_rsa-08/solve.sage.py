

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_142568718070179268160042436241976606615752435479866339982336714636121178632041487167809050508470287136117269939689172579967041843749617979532284976707315017238964580718247151971486008024305899789422639474321316564939242129088617149979641289913848041982422021649097340520020905021049710258218576372809976674951 = Integer(142568718070179268160042436241976606615752435479866339982336714636121178632041487167809050508470287136117269939689172579967041843749617979532284976707315017238964580718247151971486008024305899789422639474321316564939242129088617149979641289913848041982422021649097340520020905021049710258218576372809976674951); _sage_const_54317461305902033097513409877716379458977827749862344078064241965327158812743315134021284100660514967628043598472165014648160183704827186763668333828696983841333947744649920679635366223049935903622738211484788136844610226068342046764702849699464546216122385949437987817501517230496883851737309257537069140421 = Integer(54317461305902033097513409877716379458977827749862344078064241965327158812743315134021284100660514967628043598472165014648160183704827186763668333828696983841333947744649920679635366223049935903622738211484788136844610226068342046764702849699464546216122385949437987817501517230496883851737309257537069140421); _sage_const_9919863709722848618808738909391795675054137602904098874396284902251814361620475843905282435833448039515528946539472986745677031452665256593202770662719031639338101150832876821809108517714663878190621729669241881400967228428110956236975616998801430338905934669535995885207072483089159185639811118822238984997 = Integer(9919863709722848618808738909391795675054137602904098874396284902251814361620475843905282435833448039515528946539472986745677031452665256593202770662719031639338101150832876821809108517714663878190621729669241881400967228428110956236975616998801430338905934669535995885207072483089159185639811118822238984997); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2)
from Crypto.Util.number import long_to_bytes
from sympy import *
import gmpy2
import libnum

n = _sage_const_142568718070179268160042436241976606615752435479866339982336714636121178632041487167809050508470287136117269939689172579967041843749617979532284976707315017238964580718247151971486008024305899789422639474321316564939242129088617149979641289913848041982422021649097340520020905021049710258218576372809976674951 
e = _sage_const_54317461305902033097513409877716379458977827749862344078064241965327158812743315134021284100660514967628043598472165014648160183704827186763668333828696983841333947744649920679635366223049935903622738211484788136844610226068342046764702849699464546216122385949437987817501517230496883851737309257537069140421 
ct = _sage_const_9919863709722848618808738909391795675054137602904098874396284902251814361620475843905282435833448039515528946539472986745677031452665256593202770662719031639338101150832876821809108517714663878190621729669241881400967228428110956236975616998801430338905934669535995885207072483089159185639811118822238984997 


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = _sage_const_1 , _sage_const_0 
    for i in sub_res[::-_sage_const_1 ]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(
        map(continued_fraction, (res[_sage_const_0 :i] for i in range(_sage_const_1 , len(res))))
    )  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - _sage_const_4  * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (_sage_const_2  * a), (-b - par) // (_sage_const_2  * a)
    return x1, x2


def wienerAttack(e, n):
    for d, k in sub_fraction(
        e, n
    ):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == _sage_const_0 :  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (
            e * d - _sage_const_1 
        ) % k != _sage_const_0 :  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - _sage_const_1 ) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(_sage_const_1 , n - phi + _sage_const_1 , n)
        if px * qy == n:
            p, q = abs(int(px)), abs(
                int(qy)
            )  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(
                e, (p - _sage_const_1 ) * (q - _sage_const_1 )
            )  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print("该方法不适用")


t = wienerAttack(e, n)

print(t)

m = pow(ct, t, n)

print(long_to_bytes(m))

# NeSE{an_Example_For_wiener_attack_9asf982u309rudjksfhkjh34h34sdfiusd0fus}

